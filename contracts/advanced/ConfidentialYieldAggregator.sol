// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import {ERC7984Mock} from "../openzeppelin/ERC7984Mock.sol";

/// @title Confidential Yield Aggregator
/// @notice Demonstrates a confidential yield aggregation system with multiple strategies
/// @dev This contract demonstrates:
///      - Multiple yield strategies with encrypted allocations
///      - Encrypted yield calculations per strategy
///      - Strategy allocation with encrypted amounts
///      - Rebalancing based on encrypted yields
///      - Compounding with encrypted values
///      - Complex FHE operations: add, mul, sub, div, comparisons
/// 
/// @dev Key Concepts:
///      - Strategy: A yield-generating mechanism (e.g., lending, staking, liquidity provision)
///      - Allocation: Encrypted amount of funds allocated to each strategy
///      - Yield: Encrypted return generated by each strategy
///      - Rebalancing: Adjusting allocations based on encrypted yield performance
///      - Compounding: Reinvesting encrypted yields to generate more returns
/// 
/// @dev Educational Notes:
///      - All allocations and yields remain encrypted throughout
///      - Yield calculations work on encrypted values using FHE operations
///      - Rebalancing decisions use encrypted comparisons without revealing actual yields
///      - Demonstrates complex DeFi yield optimization with complete privacy preservation
contract ConfidentialYieldAggregator is ZamaEthereumConfig {
    /// @notice Maximum number of yield strategies
    uint8 public constant MAX_STRATEGIES = 5;
    
    /// @notice Rebalancing threshold (in basis points, e.g., 500 = 5%)
    uint16 public rebalancingThreshold;
    
    /// @notice Aggregator owner
    address public immutable owner;
    
    /// @notice Yield strategy information
    struct StrategyInfo {
        ERC7984Mock token;           // ERC7984 token contract for this strategy
        uint16 targetAllocationBps;  // Target allocation in basis points (e.g., 4000 = 40%)
        euint64 allocation;           // Encrypted current allocation
        euint64 yield;                // Encrypted yield generated
        uint256 lastYieldBlock;       // Last block when yield was calculated
        bool isActive;                // Whether strategy is active
    }
    
    /// @notice User position information
    struct UserPosition {
        euint64 totalDeposited;       // Total encrypted amount deposited
        euint64 totalYield;            // Total encrypted yield earned
        uint256 lastCompoundBlock;    // Last block when yield was compounded
        bool exists;                  // Whether user has an active position
    }
    
    /// @notice User allocations per strategy: user => strategyIndex => encrypted amount
    mapping(address => mapping(uint8 => euint64)) public userAllocations;
    
    /// @notice User positions
    mapping(address => UserPosition) public users;
    
    /// @notice Array of yield strategies
    StrategyInfo[MAX_STRATEGIES] public strategies;
    
    /// @notice Number of active strategies
    uint8 public strategyCount;
    
    /// @notice Total encrypted value across all strategies
    euint64 public totalValue;
    
    /// @notice Events
    event StrategyAdded(address indexed token, uint16 targetAllocationBps);
    event StrategyRemoved(address indexed token);
    event RebalancingThresholdUpdated(uint16 oldThreshold, uint16 newThreshold);
    event Deposit(address indexed user, euint64 amount);
    event Withdrawal(address indexed user, euint64 amount);
    event YieldAccrued(uint8 indexed strategyIndex, euint64 yield);
    event RebalancingExecuted(
        uint8 indexed strategyIndex,
        bool isIncrease,  // true = increase allocation, false = decrease
        euint64 amount
    );
    event YieldCompounded(address indexed user, euint64 yield);
    
    /// @notice Errors
    error Unauthorized();
    error InvalidStrategy();
    error StrategyAlreadyExists();
    error MaxStrategiesReached();
    error InvalidAllocation();
    error InvalidBorrower();
    error InsufficientBalance();
    error InvalidAmount();
    
    /// @notice Constructor
    /// @param _rebalancingThreshold Rebalancing threshold in basis points (e.g., 500 = 5%)
    constructor(uint16 _rebalancingThreshold) {
        owner = msg.sender;
        rebalancingThreshold = _rebalancingThreshold;
    }
    
    /// @notice Modifier to restrict access to owner
    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized();
        _;
    }
    
    /// @notice Add a yield strategy
    /// @param token ERC7984 token contract address
    /// @param targetAllocationBps Target allocation in basis points (e.g., 4000 = 40%)
    /// @dev Educational: Demonstrates adding strategies to the yield aggregator
    function addStrategy(ERC7984Mock token, uint16 targetAllocationBps) external onlyOwner {
        if (address(token) == address(0)) revert InvalidStrategy();
        if (strategyCount >= MAX_STRATEGIES) revert MaxStrategiesReached();
        if (targetAllocationBps == 0 || targetAllocationBps > 10000) revert InvalidAllocation();
        
        // Check if strategy already exists
        for (uint8 i = 0; i < strategyCount; i++) {
            if (address(strategies[i].token) == address(token)) {
                revert StrategyAlreadyExists();
            }
        }
        
        strategies[strategyCount] = StrategyInfo({
            token: token,
            targetAllocationBps: targetAllocationBps,
            allocation: FHE.asEuint64(0),
            yield: FHE.asEuint64(0),
            lastYieldBlock: block.number,
            isActive: true
        });
        
        // Grant permissions for initial zero allocation
        FHE.allowThis(strategies[strategyCount].allocation);
        
        strategyCount++;
        
        emit StrategyAdded(address(token), targetAllocationBps);
    }
    
    /// @notice Remove a yield strategy
    /// @param strategyIndex Index of strategy to remove
    /// @dev Educational: Demonstrates removing strategies from the yield aggregator
    function removeStrategy(uint8 strategyIndex) external onlyOwner {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        
        strategies[strategyIndex].isActive = false;
        
        emit StrategyRemoved(address(strategies[strategyIndex].token));
    }
    
    /// @notice Update rebalancing threshold
    /// @param newThreshold New rebalancing threshold in basis points
    function setRebalancingThreshold(uint16 newThreshold) external onlyOwner {
        if (newThreshold == 0 || newThreshold > 10000) revert InvalidAllocation();
        
        uint16 oldThreshold = rebalancingThreshold;
        rebalancingThreshold = newThreshold;
        
        emit RebalancingThresholdUpdated(oldThreshold, newThreshold);
    }
    
    /// @notice Deposit funds into the aggregator
    /// @param encryptedAmount Encrypted amount to deposit
    /// @param inputProof Input proof for encrypted amount
    /// @dev Educational: Demonstrates depositing encrypted funds
    function deposit(
        externalEuint64 encryptedAmount,
        bytes calldata inputProof
    ) external {
        // Convert external encrypted input to internal
        euint64 internalAmount = FHE.fromExternal(encryptedAmount, inputProof);
        
        // Grant transient permissions for the operation
        FHE.allowTransient(internalAmount, address(this));
        
        // Note: User should have already transferred tokens to this contract
        // using token.confidentialTransfer(address(this), amount, proof)
        
        // Update user position
        UserPosition storage position = users[msg.sender];
        if (!position.exists) {
            position.exists = true;
            position.lastCompoundBlock = block.number;
        }
        
        // Add to total deposited
        if (!FHE.isInitialized(position.totalDeposited)) {
            position.totalDeposited = FHE.asEuint64(0);
        }
        position.totalDeposited = FHE.add(position.totalDeposited, internalAmount);
        
        // Grant permissions for total deposited
        FHE.allowThis(position.totalDeposited);
        FHE.allow(position.totalDeposited, msg.sender);
        
        // Allocate to strategies based on target allocations
        _allocateToStrategies(msg.sender, internalAmount);
        
        // Update total value
        if (!FHE.isInitialized(totalValue)) {
            totalValue = FHE.asEuint64(0);
        }
        totalValue = FHE.add(totalValue, internalAmount);
        FHE.allowThis(totalValue);
        
        emit Deposit(msg.sender, internalAmount);
    }
    
    /// @notice Withdraw funds from the aggregator
    /// @param encryptedAmount Encrypted amount to withdraw
    /// @param inputProof Input proof for encrypted amount
    /// @dev Educational: Demonstrates withdrawing encrypted funds
    function withdraw(
        externalEuint64 encryptedAmount,
        bytes calldata inputProof
    ) external {
        UserPosition storage position = users[msg.sender];
        if (!position.exists) revert InvalidBorrower();
        
        // Convert external encrypted input to internal
        euint64 internalAmount = FHE.fromExternal(encryptedAmount, inputProof);
        
        // Update total deposited (subtract)
        position.totalDeposited = FHE.sub(position.totalDeposited, internalAmount);
        
        // Grant permissions for total deposited
        FHE.allowThis(position.totalDeposited);
        FHE.allow(position.totalDeposited, msg.sender);
        
        // Deallocate from strategies proportionally
        _deallocateFromStrategies(msg.sender, internalAmount);
        
        // Update total value
        totalValue = FHE.sub(totalValue, internalAmount);
        FHE.allowThis(totalValue);
        
        // Transfer tokens to user (simplified - in production would use first strategy token)
        if (strategyCount > 0 && strategies[0].isActive) {
            FHE.allowTransient(internalAmount, address(this));
            FHE.allow(internalAmount, address(strategies[0].token));
            strategies[0].token.confidentialTransfer(msg.sender, internalAmount);
        }
        
        emit Withdrawal(msg.sender, internalAmount);
    }
    
    /// @notice Calculate yield for a strategy
    /// @param strategyIndex Index of strategy
    /// @dev Educational: Demonstrates calculating yield with encrypted values
    function calculateYield(uint8 strategyIndex) 
        public 
        returns (euint64 yield) 
    {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        if (!strategies[strategyIndex].isActive) revert InvalidStrategy();
        
        StrategyInfo storage strategy = strategies[strategyIndex];
        
        // Calculate yield: allocation * yieldRate * blocksElapsed / 10000
        // For this example, we'll use a fixed yield rate (e.g., 10% per 1000 blocks)
        uint256 blocksElapsed = block.number - strategy.lastYieldBlock;
        if (blocksElapsed == 0) {
            return strategy.yield;
        }
        
        // Yield rate: 10 basis points per block (0.1% per block)
        // In production, this would be fetched from the strategy contract
        uint16 yieldRateBps = 10; // 0.1% per block
        
        // Calculate yield: (allocation * yieldRate * blocksElapsed) / 10000
        // Note: blocksElapsed is uint256, so we need to convert it safely
        // For this example, we'll cap blocksElapsed at uint64 max for conversion
        uint64 blocksElapsed64 = blocksElapsed > type(uint64).max ? type(uint64).max : uint64(blocksElapsed);
        euint64 yieldAmount = FHE.mul(strategy.allocation, FHE.asEuint64(yieldRateBps));
        yieldAmount = FHE.mul(yieldAmount, FHE.asEuint64(blocksElapsed64));
        yieldAmount = FHE.div(yieldAmount, 10000);
        
        // Add to existing yield
        strategy.yield = FHE.add(strategy.yield, yieldAmount);
        
        // Grant permissions for yield
        FHE.allowThis(strategy.yield);
        
        // Update last yield block
        strategy.lastYieldBlock = block.number;
        
        emit YieldAccrued(strategyIndex, yieldAmount);
        
        return strategy.yield;
    }
    
    /// @notice Calculate total yield across all strategies
    /// @return totalYield Encrypted total yield
    /// @dev Educational: Demonstrates aggregating encrypted yields
    function calculateTotalYield() 
        public 
        returns (euint64 totalYield) 
    {
        euint64 sum = FHE.asEuint64(0);
        
        for (uint8 i = 0; i < strategyCount; i++) {
            if (strategies[i].isActive) {
                euint64 strategyYield = calculateYield(i);
                sum = FHE.add(sum, strategyYield);
            }
        }
        
        return sum;
    }
    
    /// @notice Check if rebalancing is needed
    /// @param strategyIndex Index of strategy to check
    /// @return needsRebalancing Encrypted boolean indicating if rebalancing is needed
    /// @return currentAllocationBps Encrypted current allocation in basis points
    /// @dev Educational: Demonstrates rebalancing checks with encrypted comparisons
    function checkRebalancingNeeded(uint8 strategyIndex) 
        public 
        returns (ebool needsRebalancing, euint64 currentAllocationBps) 
    {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        
        StrategyInfo storage strategy = strategies[strategyIndex];
        
        // Calculate current allocation percentage
        // currentAllocationBps = (strategy.allocation / totalValue) * 10000
        // Note: FHE.div requires plaintext divisor, so we need to work with what we have
        // For this example, we'll use a simplified comparison
        
        // Calculate target allocation amount
        euint64 targetAmount = FHE.mul(totalValue, FHE.asEuint64(strategy.targetAllocationBps));
        targetAmount = FHE.div(targetAmount, 10000);
        
        // Calculate difference: |current - target|
        euint64 diff;
        ebool isGreater = FHE.ge(strategy.allocation, targetAmount);
        diff = FHE.select(
            isGreater,
            FHE.sub(strategy.allocation, targetAmount),
            FHE.sub(targetAmount, strategy.allocation)
        );
        
        // Calculate threshold amount
        euint64 thresholdAmount = FHE.mul(targetAmount, FHE.asEuint64(rebalancingThreshold));
        thresholdAmount = FHE.div(thresholdAmount, 10000);
        
        // Needs rebalancing if diff > threshold
        needsRebalancing = FHE.ge(diff, thresholdAmount);
        
        // Calculate current allocation percentage (simplified)
        // Since we can't divide by encrypted totalValue, we'll return allocation as proxy
        currentAllocationBps = strategy.allocation;
        
        return (needsRebalancing, currentAllocationBps);
    }
    
    /// @notice Rebalance allocations across strategies
    /// @param strategyIndex Index of strategy to rebalance
    /// @dev Educational: Demonstrates rebalancing with encrypted amounts
    function rebalance(uint8 strategyIndex) external onlyOwner {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        
        // Check if rebalancing is needed
        // Note: We can't decrypt ebool on-chain, so rebalancing must be verified off-chain
        // In production, this check would be done off-chain before calling
        checkRebalancingNeeded(strategyIndex);
        
        StrategyInfo storage strategy = strategies[strategyIndex];
        
        // Calculate target allocation
        euint64 targetAmount = FHE.mul(totalValue, FHE.asEuint64(strategy.targetAllocationBps));
        targetAmount = FHE.div(targetAmount, 10000);
        
        // Determine if we need to increase or decrease
        // Use ge (greater or equal) to check if allocation < target
        // If allocation >= target, we need to decrease (isIncrease = false)
        // If allocation < target, we need to increase (isIncrease = true)
        ebool isGreaterOrEqual = FHE.ge(strategy.allocation, targetAmount);
        
        // Calculate adjustment amount for both cases
        euint64 increaseAmount = FHE.sub(targetAmount, strategy.allocation);
        euint64 decreaseAmount = FHE.sub(strategy.allocation, targetAmount);
        
        // Select the appropriate adjustment based on whether we need to increase
        euint64 adjustment = FHE.select(isGreaterOrEqual, decreaseAmount, increaseAmount);
        
        // Update allocation
        strategy.allocation = FHE.select(
            isGreaterOrEqual,
            FHE.sub(strategy.allocation, adjustment),
            FHE.add(strategy.allocation, adjustment)
        );
        
        // Grant permissions for updated allocation
        FHE.allowThis(strategy.allocation);
        
        // Note: We can't emit ebool directly, so we'll emit the adjustment amount
        // In production, you'd handle this differently
        // For now, we'll use true as a placeholder (actual value would be determined off-chain)
        emit RebalancingExecuted(strategyIndex, true, adjustment);
    }
    
    /// @notice Compound yield for a user
    /// @dev Educational: Demonstrates compounding with encrypted values
    function compound() external {
        UserPosition storage position = users[msg.sender];
        if (!position.exists) revert InvalidBorrower();
        
        // Calculate total yield across all strategies
        // Note: totalYield is calculated but we use a simplified approach for user yield
        calculateTotalYield();
        
        // Distribute yield to user based on their allocation
        // Simplified: user gets yield proportional to their total deposited
        // In production, this would be more sophisticated
        
        // Add yield to user's position
        if (!FHE.isInitialized(position.totalYield)) {
            position.totalYield = FHE.asEuint64(0);
        }
        
        // User's share of yield = (userDeposited / totalValue) * totalYield
        // Since we can't divide by encrypted totalValue, we'll use a simplified approach
        // For this example, we'll add a portion of total yield
        euint64 userYield = FHE.mul(position.totalDeposited, FHE.asEuint64(100));
        userYield = FHE.div(userYield, 10000); // Simplified: assume 1% of deposited as yield
        
        position.totalYield = FHE.add(position.totalYield, userYield);
        position.totalDeposited = FHE.add(position.totalDeposited, userYield);
        
        // Grant permissions
        FHE.allowThis(position.totalYield);
        FHE.allowThis(position.totalDeposited);
        FHE.allow(position.totalYield, msg.sender);
        FHE.allow(position.totalDeposited, msg.sender);
        
        // Reallocate compounded yield to strategies
        _allocateToStrategies(msg.sender, userYield);
        
        // Update total value
        totalValue = FHE.add(totalValue, userYield);
        FHE.allowThis(totalValue);
        
        position.lastCompoundBlock = block.number;
        
        emit YieldCompounded(msg.sender, userYield);
    }
    
    /// @notice Allocate funds to strategies based on target allocations
    /// @param user Address of user
    /// @param amount Encrypted amount to allocate
    /// @dev Internal function to distribute funds across strategies
    function _allocateToStrategies(address user, euint64 amount) internal {
        for (uint8 i = 0; i < strategyCount; i++) {
            if (strategies[i].isActive) {
                // Calculate allocation for this strategy
                euint64 strategyAmount = FHE.mul(amount, FHE.asEuint64(strategies[i].targetAllocationBps));
                strategyAmount = FHE.div(strategyAmount, 10000);
                
                // Update user allocation
                euint64 currentAllocation = userAllocations[user][i];
                if (!FHE.isInitialized(currentAllocation)) {
                    currentAllocation = FHE.asEuint64(0);
                }
                userAllocations[user][i] = FHE.add(currentAllocation, strategyAmount);
                
                // Grant permissions
                FHE.allowThis(userAllocations[user][i]);
                FHE.allow(userAllocations[user][i], user);
                
                // Update strategy allocation
                strategies[i].allocation = FHE.add(strategies[i].allocation, strategyAmount);
                FHE.allowThis(strategies[i].allocation);
            }
        }
    }
    
    /// @notice Deallocate funds from strategies proportionally
    /// @param user Address of user
    /// @param amount Encrypted amount to deallocate
    /// @dev Internal function to remove funds from strategies
    function _deallocateFromStrategies(address user, euint64 amount) internal {
        for (uint8 i = 0; i < strategyCount; i++) {
            if (strategies[i].isActive) {
                // Calculate deallocation for this strategy
                euint64 strategyAmount = FHE.mul(amount, FHE.asEuint64(strategies[i].targetAllocationBps));
                strategyAmount = FHE.div(strategyAmount, 10000);
                
                // Update user allocation
                euint64 currentAllocation = userAllocations[user][i];
                if (!FHE.isInitialized(currentAllocation)) {
                    currentAllocation = FHE.asEuint64(0);
                }
                userAllocations[user][i] = FHE.sub(currentAllocation, strategyAmount);
                
                // Grant permissions
                FHE.allowThis(userAllocations[user][i]);
                FHE.allow(userAllocations[user][i], user);
                
                // Update strategy allocation
                strategies[i].allocation = FHE.sub(strategies[i].allocation, strategyAmount);
                FHE.allowThis(strategies[i].allocation);
            }
        }
    }
    
    /// @notice Get user allocation for a strategy
    /// @param user Address of user
    /// @param strategyIndex Index of strategy
    /// @return Encrypted allocation amount
    function getUserAllocation(address user, uint8 strategyIndex) 
        external 
        view 
        returns (euint64) 
    {
        return userAllocations[user][strategyIndex];
    }
    
    /// @notice Get total deposited for a user
    /// @param user Address of user
    /// @return Encrypted total deposited
    function getTotalDeposited(address user) 
        external 
        view 
        returns (euint64) 
    {
        return users[user].totalDeposited;
    }
    
    /// @notice Get total yield for a user
    /// @param user Address of user
    /// @return Encrypted total yield
    function getTotalYield(address user) 
        external 
        view 
        returns (euint64) 
    {
        return users[user].totalYield;
    }
}

