// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Input Proof Basics
/// @notice Explains what input proofs are and why they're needed
/// @dev This example demonstrates:
///      - What input proofs are
///      - Why input proofs are required
///      - How input proofs work
///      - The relationship between encryption and proofs
/// 
/// @dev Key Concepts:
///      - Input proofs are zero-knowledge proofs that attest correct encryption binding
///      - They prove that an encrypted value was encrypted for a specific [contract, user] pair
///      - Required for all encrypted inputs to prevent replay attacks
///      - Generated by the FHEVM client when encrypting values
///      - Verified on-chain by the FHEVM framework
contract InputProofBasics is ZamaEthereumConfig {
    /// @notice Encrypted value stored in the contract
    euint32 private _encryptedValue;
    
    /// @notice Event emitted when value is set
    event ValueSet(address indexed setter);
    
    /// @notice Set an encrypted value with input proof
    /// @param _encryptedInput The encrypted input value
    /// @param _inputProof The proof that attests the encryption is correct
    /// @dev This function demonstrates the correct usage of input proofs:
    ///      - The encrypted input must come with a proof
    ///      - The proof verifies that the encryption is bound to [this contract, msg.sender]
    ///      - Without a valid proof, the function will revert
    /// 
    /// @dev What is an input proof?
    ///      - A zero-knowledge proof generated by the FHEVM client
    ///      - Proves that the encrypted value was encrypted for this specific contract and user
    ///      - Prevents replay attacks (can't reuse encrypted values from other contracts/users)
    ///      - Required for security and correctness
    function setValue(externalEuint32 _encryptedInput, bytes calldata _inputProof) external {
        // âœ… DO: Always provide input proof with encrypted input
        // The proof is verified by FHE.fromExternal()
        // If the proof is invalid, this will revert
        _encryptedValue = FHE.fromExternal(_encryptedInput, _inputProof);
        
        // Grant permissions
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);
        
        emit ValueSet(msg.sender);
    }
    
    /// @notice Get the encrypted value
    /// @return The encrypted value
    function getEncryptedValue() external view returns (euint32) {
        return _encryptedValue;
    }
    
    /// @notice Add to the encrypted value
    /// @param _encryptedInput The encrypted input to add
    /// @param _inputProof The proof for the encrypted input
    /// @dev This demonstrates that every encrypted input needs a proof
    function addToValue(externalEuint32 _encryptedInput, bytes calldata _inputProof) external {
        // Every encrypted input must have a proof
        euint32 encryptedInput = FHE.fromExternal(_encryptedInput, _inputProof);
        
        // Perform operation
        _encryptedValue = FHE.add(_encryptedValue, encryptedInput);
        
        // Grant permissions for result
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);
    }
    
    /// @notice Example with multiple encrypted inputs
    /// @param _input1 First encrypted input
    /// @param _proof1 Proof for first input
    /// @param _input2 Second encrypted input
    /// @param _proof2 Proof for second input
    /// @dev Each encrypted input needs its own proof
    function addTwoValues(
        externalEuint32 _input1,
        bytes calldata _proof1,
        externalEuint32 _input2,
        bytes calldata _proof2
    ) external {
        // Each input needs its own proof
        euint32 encrypted1 = FHE.fromExternal(_input1, _proof1);
        euint32 encrypted2 = FHE.fromExternal(_input2, _proof2);
        
        // Perform operation
        _encryptedValue = FHE.add(encrypted1, encrypted2);
        
        // Grant permissions
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);
    }
}

