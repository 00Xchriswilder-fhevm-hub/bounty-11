# Confidential Yield Aggregator

<!-- chapter: advanced -->

## Overview

This example shows how to multiple yield strategies with encrypted allocations, encrypted yield calculations per strategy, strategy allocation with encrypted amounts, rebalancing based on encrypted yields, compounding with encrypted values. Strategy: A yield-generating mechanism (e.g., lending, staking, liquidity provision). All allocations and yields remain encrypted throughout. This example demonstrates confidential token operations with encrypted balances and transfers and shows how to manage FHE permissions for both contracts and users using external encrypted inputs with input proofs for verification.

## What You'll Learn

- **FHE.add operation** - How to perform this specific homomorphic operation on encrypted values
- **Off-chain encryption** - Encrypting values locally before sending to contract
- **FHE permissions** - Granting permissions for operations and decryption

## Key Concepts

### 1. FHE.add Operation

The `FHE.add()` function performs addition on encrypted values, computing the sum without ever decrypting the operands.

### 2. Off-Chain Encryption

Values are encrypted **locally** (on the client side) before being sent to the contract:
- Plaintext values never appear in transactions
- Encryption is cryptographically bound to [contract, user] pair
- Input proofs verify the binding

### 3. FHE Permissions

Permissions control who can:
- **Perform operations**: Contracts need `FHE.allowThis()`
- **Decrypt values**: Users need `FHE.allow()`

## Step-by-Step Walkthrough

### Step 1: Set Encrypted Values

Encrypt your values off-chain and send them to the contract using `addStrategy()`.

### Step 2: Perform FHE.add Operation

Call the function that performs `FHE.add` (e.g., `removeStrategy()`).

## Common Pitfalls

### ❌ Pitfall 1: should fail when non-owner tries to add strategy

**The Problem:** await expect(
        (aggregator.connect(signers.user) as any).addStrategy(strategyToken, 10000)
      ).to.be.revertedWithCustomError(aggr...

**Why it fails:** The operation fails due to incorrect usage, permissions, or signer mismatch.

**The Fix:** Ensure proper setup, matching signers, and correct permissions.

### ❌ Pitfall 2: should fail when adding duplicate strategy

**The Problem:** await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);

      await expect(
        (aggregator.connect(sig...

**Why it fails:** The operation fails due to incorrect usage, permissions, or signer mismatch.

**The Fix:** Ensure proper setup, matching signers, and correct permissions.

## Best Practices

1. **Always match encryption signer with transaction signer**
2. **Grant permissions immediately after creating encrypted values**
3. **Use descriptive variable names** for clarity
4. **Validate inputs** before performing operations

## Real-World Use Cases

- **Confidential Accounting**: Sum or multiply encrypted balances
- **Privacy-Preserving Analytics**: Aggregate encrypted data points
- **Confidential Calculations**: Perform financial computations on encrypted values
{% hint style="info" %}
To run this example correctly, make sure the files are placed in the following directories:

- `.sol` file → `<your-project-root-dir>/contracts/`
- `.ts` file → `<your-project-root-dir>/test/`

This ensures Hardhat can compile and test your contracts as expected.
{% endhint %}

{% tabs %}

{% tab title="ConfidentialYieldAggregator.sol" %}

```solidity
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import {ERC7984Mock} from "../openzeppelin/ERC7984Mock.sol";

/// @title Confidential Yield Aggregator
/// @notice Demonstrates a confidential yield aggregation system with multiple strategies
/// @dev This contract demonstrates:
///      - Multiple yield strategies with encrypted allocations
///      - Encrypted yield calculations per strategy
///      - Strategy allocation with encrypted amounts
///      - Rebalancing based on encrypted yields
///      - Compounding with encrypted values
///      - Complex FHE operations: add, mul, sub, div, comparisons
/// 
/// @dev Key Concepts:
///      - Strategy: A yield-generating mechanism (e.g., lending, staking, liquidity provision)
///      - Allocation: Encrypted amount of funds allocated to each strategy
///      - Yield: Encrypted return generated by each strategy
///      - Rebalancing: Adjusting allocations based on encrypted yield performance
///      - Compounding: Reinvesting encrypted yields to generate more returns
/// 
/// @dev Educational Notes:
///      - All allocations and yields remain encrypted throughout
///      - Yield calculations work on encrypted values using FHE operations
///      - Rebalancing decisions use encrypted comparisons without revealing actual yields
///      - Demonstrates complex DeFi yield optimization with complete privacy preservation
contract ConfidentialYieldAggregator is ZamaEthereumConfig {
    /// @notice Maximum number of yield strategies
    uint8 public constant MAX_STRATEGIES = 5;
    
    /// @notice Rebalancing threshold (in basis points, e.g., 500 = 5%)
    uint16 public rebalancingThreshold;
    
    /// @notice Aggregator owner
    address public immutable owner;
    
    /// @notice Yield strategy information
    struct StrategyInfo {
        ERC7984Mock token;           // ERC7984 token contract for this strategy
        uint16 targetAllocationBps;  // Target allocation in basis points (e.g., 4000 = 40%)
        euint64 allocation;           // Encrypted current allocation
        euint64 yield;                // Encrypted yield generated
        uint256 lastYieldBlock;       // Last block when yield was calculated
        bool isActive;                // Whether strategy is active
    }
    
    /// @notice User position information
    struct UserPosition {
        euint64 totalDeposited;       // Total encrypted amount deposited
        euint64 totalYield;            // Total encrypted yield earned
        uint256 lastCompoundBlock;    // Last block when yield was compounded
        bool exists;                  // Whether user has an active position
    }
    
    /// @notice User allocations per strategy: user => strategyIndex => encrypted amount
    mapping(address => mapping(uint8 => euint64)) public userAllocations;
    
    /// @notice User positions
    mapping(address => UserPosition) public users;
    
    /// @notice Array of yield strategies
    StrategyInfo[MAX_STRATEGIES] public strategies;
    
    /// @notice Number of active strategies
    uint8 public strategyCount;
    
    /// @notice Total encrypted value across all strategies
    euint64 public totalValue;
    
    /// @notice Events
    event StrategyAdded(address indexed token, uint16 targetAllocationBps);
    event StrategyRemoved(address indexed token);
    event RebalancingThresholdUpdated(uint16 oldThreshold, uint16 newThreshold);
    event Deposit(address indexed user, euint64 amount);
    event Withdrawal(address indexed user, euint64 amount);
    event YieldAccrued(uint8 indexed strategyIndex, euint64 yield);
    event RebalancingExecuted(
        uint8 indexed strategyIndex,
        bool isIncrease,  // true = increase allocation, false = decrease
        euint64 amount
    );
    event YieldCompounded(address indexed user, euint64 yield);
    
    /// @notice Errors
    error Unauthorized();
    error InvalidStrategy();
    error StrategyAlreadyExists();
    error MaxStrategiesReached();
    error InvalidAllocation();
    error InvalidBorrower();
    error InsufficientBalance();
    error InvalidAmount();
    
    /// @notice Constructor
    /// @param _rebalancingThreshold Rebalancing threshold in basis points (e.g., 500 = 5%)
    constructor(uint16 _rebalancingThreshold) {
        owner = msg.sender;
        rebalancingThreshold = _rebalancingThreshold;
    }
    
    /// @notice Modifier to restrict access to owner
    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized();
        _;
    }
    
    /// @notice Add a yield strategy
    /// @param token ERC7984 token contract address
    /// @param targetAllocationBps Target allocation in basis points (e.g., 4000 = 40%)
    /// @dev Educational: Demonstrates adding strategies to the yield aggregator
    function addStrategy(ERC7984Mock token, uint16 targetAllocationBps) external onlyOwner {
        if (address(token) == address(0)) revert InvalidStrategy();
        if (strategyCount >= MAX_STRATEGIES) revert MaxStrategiesReached();
        if (targetAllocationBps == 0 || targetAllocationBps > 10000) revert InvalidAllocation();
        
        // Check if strategy already exists
        for (uint8 i = 0; i < strategyCount; i++) {
            if (address(strategies[i].token) == address(token)) {
                revert StrategyAlreadyExists();
            }
        }
        
        strategies[strategyCount] = StrategyInfo({
            token: token,
            targetAllocationBps: targetAllocationBps,
            allocation: FHE.asEuint64(0),
            yield: FHE.asEuint64(0),
            lastYieldBlock: block.number,
            isActive: true
        });
        
        // Grant permissions for initial zero allocation
        FHE.allowThis(strategies[strategyCount].allocation);
        
        strategyCount++;
        
        emit StrategyAdded(address(token), targetAllocationBps);
    }
    
    /// @notice Remove a yield strategy
    /// @param strategyIndex Index of strategy to remove
    /// @dev Educational: Demonstrates removing strategies from the yield aggregator
    function removeStrategy(uint8 strategyIndex) external onlyOwner {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        
        strategies[strategyIndex].isActive = false;
        
        emit StrategyRemoved(address(strategies[strategyIndex].token));
    }
    
    /// @notice Update rebalancing threshold
    /// @param newThreshold New rebalancing threshold in basis points
    function setRebalancingThreshold(uint16 newThreshold) external onlyOwner {
        if (newThreshold == 0 || newThreshold > 10000) revert InvalidAllocation();
        
        uint16 oldThreshold = rebalancingThreshold;
        rebalancingThreshold = newThreshold;
        
        emit RebalancingThresholdUpdated(oldThreshold, newThreshold);
    }
    
    /// @notice Deposit funds into the aggregator
    /// @param encryptedAmount Encrypted amount to deposit
    /// @param inputProof Input proof for encrypted amount
    /// @dev Educational: Demonstrates depositing encrypted funds
    function deposit(
        externalEuint64 encryptedAmount,
        bytes calldata inputProof
    ) external {
        // Convert external encrypted input to internal
        euint64 internalAmount = FHE.fromExternal(encryptedAmount, inputProof);
        
        // Grant transient permissions for the operation
        FHE.allowTransient(internalAmount, address(this));
        
        // Note: User should have already transferred tokens to this contract
        // using token.confidentialTransfer(address(this), amount, proof)
        
        // Update user position
        UserPosition storage position = users[msg.sender];
        if (!position.exists) {
            position.exists = true;
            position.lastCompoundBlock = block.number;
        }
        
        // Add to total deposited
        if (!FHE.isInitialized(position.totalDeposited)) {
            position.totalDeposited = FHE.asEuint64(0);
        }
        position.totalDeposited = FHE.add(position.totalDeposited, internalAmount);
        
        // Grant permissions for total deposited
        FHE.allowThis(position.totalDeposited);
        FHE.allow(position.totalDeposited, msg.sender);
        
        // Allocate to strategies based on target allocations
        _allocateToStrategies(msg.sender, internalAmount);
        
        // Update total value
        if (!FHE.isInitialized(totalValue)) {
            totalValue = FHE.asEuint64(0);
        }
        totalValue = FHE.add(totalValue, internalAmount);
        FHE.allowThis(totalValue);
        
        emit Deposit(msg.sender, internalAmount);
    }
    
    /// @notice Withdraw funds from the aggregator
    /// @param encryptedAmount Encrypted amount to withdraw
    /// @param inputProof Input proof for encrypted amount
    /// @dev Educational: Demonstrates withdrawing encrypted funds
    function withdraw(
        externalEuint64 encryptedAmount,
        bytes calldata inputProof
    ) external {
        UserPosition storage position = users[msg.sender];
        if (!position.exists) revert InvalidBorrower();
        
        // Convert external encrypted input to internal
        euint64 internalAmount = FHE.fromExternal(encryptedAmount, inputProof);
        
        // Update total deposited (subtract)
        position.totalDeposited = FHE.sub(position.totalDeposited, internalAmount);
        
        // Grant permissions for total deposited
        FHE.allowThis(position.totalDeposited);
        FHE.allow(position.totalDeposited, msg.sender);
        
        // Deallocate from strategies proportionally
        _deallocateFromStrategies(msg.sender, internalAmount);
        
        // Update total value
        totalValue = FHE.sub(totalValue, internalAmount);
        FHE.allowThis(totalValue);
        
        // Transfer tokens to user (simplified - in production would use first strategy token)
        if (strategyCount > 0 && strategies[0].isActive) {
            FHE.allowTransient(internalAmount, address(this));
            FHE.allow(internalAmount, address(strategies[0].token));
            strategies[0].token.confidentialTransfer(msg.sender, internalAmount);
        }
        
        emit Withdrawal(msg.sender, internalAmount);
    }
    
    /// @notice Calculate yield for a strategy
    /// @param strategyIndex Index of strategy
    /// @dev Educational: Demonstrates calculating yield with encrypted values
    function calculateYield(uint8 strategyIndex) 
        public 
        returns (euint64 yield) 
    {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        if (!strategies[strategyIndex].isActive) revert InvalidStrategy();
        
        StrategyInfo storage strategy = strategies[strategyIndex];
        
        // Calculate yield: allocation * yieldRate * blocksElapsed / 10000
        // For this example, we'll use a fixed yield rate (e.g., 10% per 1000 blocks)
        uint256 blocksElapsed = block.number - strategy.lastYieldBlock;
        if (blocksElapsed == 0) {
            return strategy.yield;
        }
        
        // Yield rate: 10 basis points per block (0.1% per block)
        // In production, this would be fetched from the strategy contract
        uint16 yieldRateBps = 10; // 0.1% per block
        
        // Calculate yield: (allocation * yieldRate * blocksElapsed) / 10000
        // Note: blocksElapsed is uint256, so we need to convert it safely
        // For this example, we'll cap blocksElapsed at uint64 max for conversion
        uint64 blocksElapsed64 = blocksElapsed > type(uint64).max ? type(uint64).max : uint64(blocksElapsed);
        euint64 yieldAmount = FHE.mul(strategy.allocation, FHE.asEuint64(yieldRateBps));
        yieldAmount = FHE.mul(yieldAmount, FHE.asEuint64(blocksElapsed64));
        yieldAmount = FHE.div(yieldAmount, 10000);
        
        // Add to existing yield
        strategy.yield = FHE.add(strategy.yield, yieldAmount);
        
        // Grant permissions for yield
        FHE.allowThis(strategy.yield);
        
        // Update last yield block
        strategy.lastYieldBlock = block.number;
        
        emit YieldAccrued(strategyIndex, yieldAmount);
        
        return strategy.yield;
    }
    
    /// @notice Calculate total yield across all strategies
    /// @return totalYield Encrypted total yield
    /// @dev Educational: Demonstrates aggregating encrypted yields
    function calculateTotalYield() 
        public 
        returns (euint64 totalYield) 
    {
        euint64 sum = FHE.asEuint64(0);
        
        for (uint8 i = 0; i < strategyCount; i++) {
            if (strategies[i].isActive) {
                euint64 strategyYield = calculateYield(i);
                sum = FHE.add(sum, strategyYield);
            }
        }
        
        return sum;
    }
    
    /// @notice Check if rebalancing is needed
    /// @param strategyIndex Index of strategy to check
    /// @return needsRebalancing Encrypted boolean indicating if rebalancing is needed
    /// @return currentAllocationBps Encrypted current allocation in basis points
    /// @dev Educational: Demonstrates rebalancing checks with encrypted comparisons
    function checkRebalancingNeeded(uint8 strategyIndex) 
        public 
        returns (ebool needsRebalancing, euint64 currentAllocationBps) 
    {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        
        StrategyInfo storage strategy = strategies[strategyIndex];
        
        // Calculate current allocation percentage
        // currentAllocationBps = (strategy.allocation / totalValue) * 10000
        // Note: FHE.div requires plaintext divisor, so we need to work with what we have
        // For this example, we'll use a simplified comparison
        
        // Calculate target allocation amount
        euint64 targetAmount = FHE.mul(totalValue, FHE.asEuint64(strategy.targetAllocationBps));
        targetAmount = FHE.div(targetAmount, 10000);
        
        // Calculate difference: |current - target|
        euint64 diff;
        ebool isGreater = FHE.ge(strategy.allocation, targetAmount);
        diff = FHE.select(
            isGreater,
            FHE.sub(strategy.allocation, targetAmount),
            FHE.sub(targetAmount, strategy.allocation)
        );
        
        // Calculate threshold amount
        euint64 thresholdAmount = FHE.mul(targetAmount, FHE.asEuint64(rebalancingThreshold));
        thresholdAmount = FHE.div(thresholdAmount, 10000);
        
        // Needs rebalancing if diff > threshold
        needsRebalancing = FHE.ge(diff, thresholdAmount);
        
        // Calculate current allocation percentage (simplified)
        // Since we can't divide by encrypted totalValue, we'll return allocation as proxy
        currentAllocationBps = strategy.allocation;
        
        return (needsRebalancing, currentAllocationBps);
    }
    
    /// @notice Rebalance allocations across strategies
    /// @param strategyIndex Index of strategy to rebalance
    /// @dev Educational: Demonstrates rebalancing with encrypted amounts
    function rebalance(uint8 strategyIndex) external onlyOwner {
        if (strategyIndex >= strategyCount) revert InvalidStrategy();
        
        // Check if rebalancing is needed
        // Note: We can't decrypt ebool on-chain, so rebalancing must be verified off-chain
        // In production, this check would be done off-chain before calling
        checkRebalancingNeeded(strategyIndex);
        
        StrategyInfo storage strategy = strategies[strategyIndex];
        
        // Calculate target allocation
        euint64 targetAmount = FHE.mul(totalValue, FHE.asEuint64(strategy.targetAllocationBps));
        targetAmount = FHE.div(targetAmount, 10000);
        
        // Determine if we need to increase or decrease
        // Use ge (greater or equal) to check if allocation < target
        // If allocation >= target, we need to decrease (isIncrease = false)
        // If allocation < target, we need to increase (isIncrease = true)
        ebool isGreaterOrEqual = FHE.ge(strategy.allocation, targetAmount);
        
        // Calculate adjustment amount for both cases
        euint64 increaseAmount = FHE.sub(targetAmount, strategy.allocation);
        euint64 decreaseAmount = FHE.sub(strategy.allocation, targetAmount);
        
        // Select the appropriate adjustment based on whether we need to increase
        euint64 adjustment = FHE.select(isGreaterOrEqual, decreaseAmount, increaseAmount);
        
        // Update allocation
        strategy.allocation = FHE.select(
            isGreaterOrEqual,
            FHE.sub(strategy.allocation, adjustment),
            FHE.add(strategy.allocation, adjustment)
        );
        
        // Grant permissions for updated allocation
        FHE.allowThis(strategy.allocation);
        
        // Note: We can't emit ebool directly, so we'll emit the adjustment amount
        // In production, you'd handle this differently
        // For now, we'll use true as a placeholder (actual value would be determined off-chain)
        emit RebalancingExecuted(strategyIndex, true, adjustment);
    }
    
    /// @notice Compound yield for a user
    /// @dev Educational: Demonstrates compounding with encrypted values
    function compound() external {
        UserPosition storage position = users[msg.sender];
        if (!position.exists) revert InvalidBorrower();
        
        // Calculate total yield across all strategies
        // Note: totalYield is calculated but we use a simplified approach for user yield
        calculateTotalYield();
        
        // Distribute yield to user based on their allocation
        // Simplified: user gets yield proportional to their total deposited
        // In production, this would be more sophisticated
        
        // Add yield to user's position
        if (!FHE.isInitialized(position.totalYield)) {
            position.totalYield = FHE.asEuint64(0);
        }
        
        // User's share of yield = (userDeposited / totalValue) * totalYield
        // Since we can't divide by encrypted totalValue, we'll use a simplified approach
        // For this example, we'll add a portion of total yield
        euint64 userYield = FHE.mul(position.totalDeposited, FHE.asEuint64(100));
        userYield = FHE.div(userYield, 10000); // Simplified: assume 1% of deposited as yield
        
        position.totalYield = FHE.add(position.totalYield, userYield);
        position.totalDeposited = FHE.add(position.totalDeposited, userYield);
        
        // Grant permissions
        FHE.allowThis(position.totalYield);
        FHE.allowThis(position.totalDeposited);
        FHE.allow(position.totalYield, msg.sender);
        FHE.allow(position.totalDeposited, msg.sender);
        
        // Reallocate compounded yield to strategies
        _allocateToStrategies(msg.sender, userYield);
        
        // Update total value
        totalValue = FHE.add(totalValue, userYield);
        FHE.allowThis(totalValue);
        
        position.lastCompoundBlock = block.number;
        
        emit YieldCompounded(msg.sender, userYield);
    }
    
    /// @notice Allocate funds to strategies based on target allocations
    /// @param user Address of user
    /// @param amount Encrypted amount to allocate
    /// @dev Internal function to distribute funds across strategies
    function _allocateToStrategies(address user, euint64 amount) internal {
        for (uint8 i = 0; i < strategyCount; i++) {
            if (strategies[i].isActive) {
                // Calculate allocation for this strategy
                euint64 strategyAmount = FHE.mul(amount, FHE.asEuint64(strategies[i].targetAllocationBps));
                strategyAmount = FHE.div(strategyAmount, 10000);
                
                // Update user allocation
                euint64 currentAllocation = userAllocations[user][i];
                if (!FHE.isInitialized(currentAllocation)) {
                    currentAllocation = FHE.asEuint64(0);
                }
                userAllocations[user][i] = FHE.add(currentAllocation, strategyAmount);
                
                // Grant permissions
                FHE.allowThis(userAllocations[user][i]);
                FHE.allow(userAllocations[user][i], user);
                
                // Update strategy allocation
                strategies[i].allocation = FHE.add(strategies[i].allocation, strategyAmount);
                FHE.allowThis(strategies[i].allocation);
            }
        }
    }
    
    /// @notice Deallocate funds from strategies proportionally
    /// @param user Address of user
    /// @param amount Encrypted amount to deallocate
    /// @dev Internal function to remove funds from strategies
    function _deallocateFromStrategies(address user, euint64 amount) internal {
        for (uint8 i = 0; i < strategyCount; i++) {
            if (strategies[i].isActive) {
                // Calculate deallocation for this strategy
                euint64 strategyAmount = FHE.mul(amount, FHE.asEuint64(strategies[i].targetAllocationBps));
                strategyAmount = FHE.div(strategyAmount, 10000);
                
                // Update user allocation
                euint64 currentAllocation = userAllocations[user][i];
                if (!FHE.isInitialized(currentAllocation)) {
                    currentAllocation = FHE.asEuint64(0);
                }
                userAllocations[user][i] = FHE.sub(currentAllocation, strategyAmount);
                
                // Grant permissions
                FHE.allowThis(userAllocations[user][i]);
                FHE.allow(userAllocations[user][i], user);
                
                // Update strategy allocation
                strategies[i].allocation = FHE.sub(strategies[i].allocation, strategyAmount);
                FHE.allowThis(strategies[i].allocation);
            }
        }
    }
    
    /// @notice Get user allocation for a strategy
    /// @param user Address of user
    /// @param strategyIndex Index of strategy
    /// @return Encrypted allocation amount
    function getUserAllocation(address user, uint8 strategyIndex) 
        external 
        view 
        returns (euint64) 
    {
        return userAllocations[user][strategyIndex];
    }
    
    /// @notice Get total deposited for a user
    /// @param user Address of user
    /// @return Encrypted total deposited
    function getTotalDeposited(address user) 
        external 
        view 
        returns (euint64) 
    {
        return users[user].totalDeposited;
    }
    
    /// @notice Get total yield for a user
    /// @param user Address of user
    /// @return Encrypted total yield
    function getTotalYield(address user) 
        external 
        view 
        returns (euint64) 
    {
        return users[user].totalYield;
    }
}


```

{% endtab %}

{% tab title="ConfidentialYieldAggregator.ts" %}

```typescript
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { ethers, fhevm } from "hardhat";
import { expect } from "chai";
import { FhevmType } from "@fhevm/hardhat-plugin";
import type { Contract } from "ethers";
type ConfidentialYieldAggregator = Contract;
type ConfidentialYieldAggregator__factory = any;
type ERC7984Mock = Contract;
type ERC7984Mock__factory = any;

/**
 * @chapter advanced
 * @title Confidential Yield Aggregator Test Suite
 * @notice Tests for ConfidentialYieldAggregator contract demonstrating complex FHE operations
 * @dev This test suite shows:
 *      - ✅ Strategy management (add/remove strategies)
 *      - ✅ Depositing and withdrawing encrypted funds
 *      - ✅ Calculating yield with encrypted values
 *      - ✅ Rebalancing based on encrypted allocations
 *      - ✅ Compounding yield with encrypted amounts
 *      - ❌ Failure cases and edge conditions
 */

type Signers = {
  deployer: HardhatEthersSigner;
  owner: HardhatEthersSigner;
  user: HardhatEthersSigner;
  alice: HardhatEthersSigner;
};

async function deployFixture() {
  const rebalancingThreshold = 500; // 5% in basis points

  // Deploy ERC7984 tokens
  let tokenFactory: ERC7984Mock__factory;
  try {
    tokenFactory = await ethers.getContractFactory("contracts/ERC7984Mock.sol:ERC7984Mock") as unknown as ERC7984Mock__factory;
  } catch {
    tokenFactory = await ethers.getContractFactory("contracts/openzeppelin/ERC7984Mock.sol:ERC7984Mock") as unknown as ERC7984Mock__factory;
  }

  const owner = (await ethers.getSigners())[1];
  const strategyToken = (await tokenFactory.deploy(
    await owner.getAddress(),
    "Strategy Token",
    "ST",
    "https://strategy-token.com"
  )) as unknown as ERC7984Mock;

  // Deploy yield aggregator (deployer becomes owner)
  const deployer = (await ethers.getSigners())[0];
  const aggregatorFactory = (await ethers.getContractFactory("ConfidentialYieldAggregator")) as unknown as ConfidentialYieldAggregator__factory;
  const aggregator = (await aggregatorFactory.connect(deployer).deploy(rebalancingThreshold)) as ConfidentialYieldAggregator;
  const aggregatorAddress = await aggregator.getAddress();

  return { aggregator, strategyToken, aggregatorAddress };
}

describe("ConfidentialYieldAggregator", function () {
  let signers: Signers;
  let aggregator: ConfidentialYieldAggregator;
  let strategyToken: ERC7984Mock;
  let aggregatorAddress: string;

  before(async function () {
    const ethSigners: HardhatEthersSigner[] = await ethers.getSigners();
    signers = {
      deployer: ethSigners[0],
      owner: ethSigners[1],
      user: ethSigners[2],
      alice: ethSigners[3],
    };
  });

  beforeEach(async function () {
    if (!fhevm.isMock) {
      console.warn(`This hardhat test suite cannot run on Sepolia Testnet`);
      this.skip();
    }

    ({ aggregator, strategyToken, aggregatorAddress } = await deployFixture());
  });

  describe("✅ Deployment", function () {
    it("should set the right owner", async function () {
      expect(await aggregator.owner()).to.equal(signers.deployer.address);
    });

    it("should set the right rebalancing threshold", async function () {
      expect(await aggregator.rebalancingThreshold()).to.equal(500); // 5%
    });

    it("should have zero strategy count initially", async function () {
      expect(await aggregator.strategyCount()).to.equal(0);
    });
  });

  describe("✅ Strategy Management", function () {
    it("should allow owner to add strategies", async function () {
      const targetAllocation = 10000; // 100% in basis points

      await expect((aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, targetAllocation))
        .to.emit(aggregator, "StrategyAdded")
        .withArgs(await strategyToken.getAddress(), targetAllocation);

      expect(await aggregator.strategyCount()).to.equal(1);

      // Check strategy info (strategies array is public, so we can access it)
      const strategyInfo = await aggregator.strategies(0);
      expect(strategyInfo[0]).to.equal(await strategyToken.getAddress()); // token
      expect(strategyInfo[1]).to.equal(targetAllocation); // targetAllocationBps
      expect(strategyInfo[5]).to.be.true; // isActive (index 5: token, targetAllocationBps, allocation, yield, lastYieldBlock, isActive)
    });

    it("should allow adding multiple strategies", async function () {
      // Deploy additional token
      const owner = (await ethers.getSigners())[1];
      let tokenFactory: ERC7984Mock__factory;
      try {
        tokenFactory = await ethers.getContractFactory("contracts/ERC7984Mock.sol:ERC7984Mock") as unknown as ERC7984Mock__factory;
      } catch {
        tokenFactory = await ethers.getContractFactory("contracts/openzeppelin/ERC7984Mock.sol:ERC7984Mock") as unknown as ERC7984Mock__factory;
      }

      const token2 = (await tokenFactory.deploy(
        await owner.getAddress(),
        "Token 2",
        "TK2",
        "https://token2.com"
      )) as unknown as ERC7984Mock;

      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 5000);
      await (aggregator.connect(signers.deployer) as any).addStrategy(token2, 5000);

      expect(await aggregator.strategyCount()).to.equal(2);
    });

    it("should allow owner to remove strategy", async function () {
      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);

      await expect((aggregator.connect(signers.deployer) as any).removeStrategy(0))
        .to.emit(aggregator, "StrategyRemoved");

      const strategyInfo = await aggregator.strategies(0);
      expect(strategyInfo[5]).to.be.false; // isActive (index 5)
    });

    it("should allow updating rebalancing threshold", async function () {
      const newThreshold = 1000; // 10%

      await expect((aggregator.connect(signers.deployer) as any).setRebalancingThreshold(newThreshold))
        .to.emit(aggregator, "RebalancingThresholdUpdated")
        .withArgs(500, newThreshold);

      expect(await aggregator.rebalancingThreshold()).to.equal(newThreshold);
    });
  });

  describe("❌ Strategy Management Error Cases", function () {
    it("should fail when non-owner tries to add strategy", async function () {
      await expect(
        (aggregator.connect(signers.user) as any).addStrategy(strategyToken, 10000)
      ).to.be.revertedWithCustomError(aggregator, "Unauthorized");
    });

    it("should fail when adding duplicate strategy", async function () {
      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);

      await expect(
        (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 5000)
      ).to.be.revertedWithCustomError(aggregator, "StrategyAlreadyExists");
    });
  });

  describe("✅ Deposits and Withdrawals", function () {
    beforeEach(async function () {
      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);
    });

    it("should allow depositing funds", async function () {
      const depositAmount = 1000;
      const tokenAddress = await strategyToken.getAddress();
      
      // Create encrypted input for token contract (for minting)
      const encryptedMint = await fhevm
        .createEncryptedInput(tokenAddress, await signers.owner.getAddress())
        .add64(depositAmount)
        .encrypt();

      // Mint tokens to user first
      await (strategyToken.connect(signers.owner) as any)
        .getFunction("$_mint(address,bytes32,bytes)")
        .send(signers.user.address, encryptedMint.handles[0], encryptedMint.inputProof);

      // Transfer tokens to aggregator (needed for deposit)
      const encryptedTransfer = await fhevm
        .createEncryptedInput(tokenAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.user) as any)
        .getFunction("$_transfer(address,address,bytes32,bytes)")
        .send(
          signers.user.address,
          aggregatorAddress,
          encryptedTransfer.handles[0],
          encryptedTransfer.inputProof
        );

      // Create encrypted input for aggregator deposit
      const encrypted = await fhevm
        .createEncryptedInput(aggregatorAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      // Deposit
      await (aggregator.connect(signers.user) as any).deposit(encrypted.handles[0], encrypted.inputProof);

      // Check total deposited
      const encryptedDeposited = await (aggregator as any).getTotalDeposited(signers.user.address);
      expect(encryptedDeposited).to.not.eq(ethers.ZeroHash);
    });

    it("should allow withdrawing funds", async function () {
      const depositAmount = 1000;
      const withdrawAmount = 300;
      const tokenAddress = await strategyToken.getAddress();

      // Mint and deposit
      const encryptedMint = await fhevm
        .createEncryptedInput(tokenAddress, await signers.owner.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.owner) as any)
        .getFunction("$_mint(address,bytes32,bytes)")
        .send(signers.user.address, encryptedMint.handles[0], encryptedMint.inputProof);

      const encryptedTransfer = await fhevm
        .createEncryptedInput(tokenAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.user) as any)
        .getFunction("$_transfer(address,address,bytes32,bytes)")
        .send(
          signers.user.address,
          aggregatorAddress,
          encryptedTransfer.handles[0],
          encryptedTransfer.inputProof
        );

      const encryptedDeposit = await fhevm
        .createEncryptedInput(aggregatorAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (aggregator.connect(signers.user) as any).deposit(encryptedDeposit.handles[0], encryptedDeposit.inputProof);

      // Withdraw
      const encryptedWithdraw = await fhevm
        .createEncryptedInput(aggregatorAddress, await signers.user.getAddress())
        .add64(withdrawAmount)
        .encrypt();

      await (aggregator.connect(signers.user) as any).withdraw(encryptedWithdraw.handles[0], encryptedWithdraw.inputProof);

      // Check balance is not zero (still has remaining)
      const encryptedDeposited = await (aggregator as any).getTotalDeposited(signers.user.address);
      expect(encryptedDeposited).to.not.eq(ethers.ZeroHash);
    });
  });

  describe("✅ Yield Calculations", function () {
    beforeEach(async function () {
      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);
      
      // Deposit funds first
      const depositAmount = 1000;
      const tokenAddress = await strategyToken.getAddress();
      
      const encryptedMint = await fhevm
        .createEncryptedInput(tokenAddress, await signers.owner.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.owner) as any)
        .getFunction("$_mint(address,bytes32,bytes)")
        .send(signers.user.address, encryptedMint.handles[0], encryptedMint.inputProof);

      const encryptedTransfer = await fhevm
        .createEncryptedInput(tokenAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.user) as any)
        .getFunction("$_transfer(address,address,bytes32,bytes)")
        .send(
          signers.user.address,
          aggregatorAddress,
          encryptedTransfer.handles[0],
          encryptedTransfer.inputProof
        );

      const encryptedDeposit = await fhevm
        .createEncryptedInput(aggregatorAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (aggregator.connect(signers.user) as any).deposit(encryptedDeposit.handles[0], encryptedDeposit.inputProof);
    });

    it("should calculate yield for a strategy", async function () {
      // Calculate yield (this returns an euint64 handle)
      const encryptedYield = await (aggregator.connect(signers.user) as any).calculateYield(0);
      expect(encryptedYield).to.not.eq(ethers.ZeroHash);
    });

    it("should calculate total yield across all strategies", async function () {
      // Calculate total yield (this returns an euint64 handle)
      const tx = await (aggregator.connect(signers.user) as any).calculateTotalYield();
      await tx.wait();
      
      // Verify the transaction succeeded
      expect(tx).to.not.be.undefined;
      expect(tx.hash).to.not.be.undefined;
    });
  });

  describe("✅ Rebalancing", function () {
    beforeEach(async function () {
      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);
      
      // Deposit funds
      const depositAmount = 1000;
      const tokenAddress = await strategyToken.getAddress();
      
      const encryptedMint = await fhevm
        .createEncryptedInput(tokenAddress, await signers.owner.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.owner) as any)
        .getFunction("$_mint(address,bytes32,bytes)")
        .send(signers.user.address, encryptedMint.handles[0], encryptedMint.inputProof);

      const encryptedTransfer = await fhevm
        .createEncryptedInput(tokenAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.user) as any)
        .getFunction("$_transfer(address,address,bytes32,bytes)")
        .send(
          signers.user.address,
          aggregatorAddress,
          encryptedTransfer.handles[0],
          encryptedTransfer.inputProof
        );

      const encryptedDeposit = await fhevm
        .createEncryptedInput(aggregatorAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (aggregator.connect(signers.user) as any).deposit(encryptedDeposit.handles[0], encryptedDeposit.inputProof);
    });

    it("should check if rebalancing is needed", async function () {
      // Check rebalancing (this returns ebool and euint64 handles)
      const tx = await (aggregator.connect(signers.user) as any).checkRebalancingNeeded(0);
      await tx.wait();
      
      // Verify the transaction succeeded
      expect(tx).to.not.be.undefined;
      expect(tx.hash).to.not.be.undefined;
    });

    it("should allow rebalancing strategies", async function () {
      // Note: In production, rebalancing would be verified off-chain first
      // For this test, we'll just verify the function can be called
      const tx = await (aggregator.connect(signers.deployer) as any).rebalance(0);
      await tx.wait();
      
      // Verify the transaction succeeded
      expect(tx).to.not.be.undefined;
      expect(tx.hash).to.not.be.undefined;
    });
  });

  describe("✅ Compounding", function () {
    beforeEach(async function () {
      await (aggregator.connect(signers.deployer) as any).addStrategy(strategyToken, 10000);
      
      // Deposit funds
      const depositAmount = 1000;
      const tokenAddress = await strategyToken.getAddress();
      
      const encryptedMint = await fhevm
        .createEncryptedInput(tokenAddress, await signers.owner.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.owner) as any)
        .getFunction("$_mint(address,bytes32,bytes)")
        .send(signers.user.address, encryptedMint.handles[0], encryptedMint.inputProof);

      const encryptedTransfer = await fhevm
        .createEncryptedInput(tokenAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (strategyToken.connect(signers.user) as any)
        .getFunction("$_transfer(address,address,bytes32,bytes)")
        .send(
          signers.user.address,
          aggregatorAddress,
          encryptedTransfer.handles[0],
          encryptedTransfer.inputProof
        );

      const encryptedDeposit = await fhevm
        .createEncryptedInput(aggregatorAddress, await signers.user.getAddress())
        .add64(depositAmount)
        .encrypt();

      await (aggregator.connect(signers.user) as any).deposit(encryptedDeposit.handles[0], encryptedDeposit.inputProof);
    });

    it("should allow compounding yield", async function () {
      // Compound yield
      const tx = await (aggregator.connect(signers.user) as any).compound();
      await tx.wait();
      
      // Verify the transaction succeeded
      expect(tx).to.not.be.undefined;
      expect(tx.hash).to.not.be.undefined;
      
      // Check total yield
      const encryptedYield = await (aggregator as any).getTotalYield(signers.user.address);
      expect(encryptedYield).to.not.eq(ethers.ZeroHash);
    });
  });
});


```

{% endtab %}

{% endtabs %}
