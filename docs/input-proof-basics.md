# Input Proof Basics

<!-- chapter: input-proofs -->

## Overview

Input proofs are zero-knowledge proofs that attest correct encryption binding. This example demonstrates encrypting and handling multiple values in a single transaction using external encrypted inputs with input proofs for verification and shows how to manage FHE permissions for both contracts and users using external encrypted inputs with input proofs for verification.

## What You'll Learn

- **FHE.add operation** - How to perform this specific homomorphic operation on encrypted values
- **Off-chain encryption** - Encrypting values locally before sending to contract
- **FHE permissions** - Granting permissions for operations and decryption

## Key Concepts

### 1. Input

proofs are zero-knowledge proofs that attest correct encryption binding

### 2. They

prove that an encrypted value was encrypted for a specific [contract, user] pair

### 3. Required

for all encrypted inputs to prevent replay attacks

### 4. Generated

by the FHEVM client when encrypting values

### 5. Verified

on-chain by the FHEVM framework

### 6. The

encrypted input must come with a proof

### 7. The

proof verifies that the encryption is bound to [this contract, msg.sender]

### 8. Without

a valid proof, the function will revert

### 9. A

zero-knowledge proof generated by the FHEVM client

### 10. Proves

that the encrypted value was encrypted for this specific contract and user

### 11. Prevents

replay attacks (can't reuse encrypted values from other contracts/users)

### 12. Required

for security and correctness

## Step-by-Step Walkthrough

### Step 1: Set Encrypted Values

Encrypt your values off-chain and send them to the contract using `setValue()`.

### Step 2: Perform FHE.add Operation

Call the function that performs `FHE.add` (e.g., `getEncryptedValue()`).

### Step 3: Decrypt Result

Use `userDecrypt` to retrieve the plaintext result.

## Common Pitfalls

### ❌ Pitfall 1: should fail when using wrong signer for encrypted input

**The Problem:** Common pitfall: Using wrong signer address in createEncryptedInput

**Why it fails:** The operation fails due to incorrect usage, permissions, or signer mismatch.

**The Fix:** Ensure proper setup, matching signers, and correct permissions.

### ❌ Pitfall 2: should fail when using invalid input proof

**The Problem:** Use invalid proof (wrong format)

**Why it fails:** The operation fails due to incorrect usage, permissions, or signer mismatch.

**The Fix:** Ensure proper setup, matching signers, and correct permissions.

### ❌ Pitfall 3: should fail when using proof for different handle

**The Problem:** Use proof from encrypted1 with handle from encrypted2 (should fail)

**Why it fails:** The operation fails due to incorrect usage, permissions, or signer mismatch.

**The Fix:** Ensure proper setup, matching signers, and correct permissions.

## Best Practices

1. **Always match encryption signer with transaction signer**
2. **Grant permissions immediately after creating encrypted values**
3. **Use descriptive variable names** for clarity
4. **Validate inputs** before performing operations

## Real-World Use Cases

- **Confidential Accounting**: Sum or multiply encrypted balances
- **Privacy-Preserving Analytics**: Aggregate encrypted data points
- **Confidential Calculations**: Perform financial computations on encrypted values
{% hint style="info" %}
To run this example correctly, make sure the files are placed in the following directories:

- `.sol` file → `<your-project-root-dir>/contracts/`
- `.ts` file → `<your-project-root-dir>/test/`

This ensures Hardhat can compile and test your contracts as expected.
{% endhint %}

{% tabs %}

{% tab title="InputProofBasics.sol" %}

```solidity
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Input Proof Basics
/// @notice Explains what input proofs are and why they're needed
/// @dev This example demonstrates:
///      - What input proofs are
///      - Why input proofs are required
///      - How input proofs work
///      - The relationship between encryption and proofs
/// 
/// @dev Key Concepts:
///      - Input proofs are zero-knowledge proofs that attest correct encryption binding
///      - They prove that an encrypted value was encrypted for a specific [contract, user] pair
///      - Required for all encrypted inputs to prevent replay attacks
///      - Generated by the FHEVM client when encrypting values
///      - Verified on-chain by the FHEVM framework
contract InputProofBasics is ZamaEthereumConfig {
    /// @notice Encrypted value stored in the contract
    euint32 private _encryptedValue;
    
    /// @notice Event emitted when value is set
    event ValueSet(address indexed setter);
    
    /// @notice Set an encrypted value with input proof
    /// @param _encryptedInput The encrypted input value
    /// @param _inputProof The proof that attests the encryption is correct
    /// @dev This function demonstrates the correct usage of input proofs:
    ///      - The encrypted input must come with a proof
    ///      - The proof verifies that the encryption is bound to [this contract, msg.sender]
    ///      - Without a valid proof, the function will revert
    /// 
    /// @dev What is an input proof?
    ///      - A zero-knowledge proof generated by the FHEVM client
    ///      - Proves that the encrypted value was encrypted for this specific contract and user
    ///      - Prevents replay attacks (can't reuse encrypted values from other contracts/users)
    ///      - Required for security and correctness
    function setValue(externalEuint32 _encryptedInput, bytes calldata _inputProof) external {
        // ✅ DO: Always provide input proof with encrypted input
        // The proof is verified by FHE.fromExternal()
        // If the proof is invalid, this will revert
        _encryptedValue = FHE.fromExternal(_encryptedInput, _inputProof);
        
        // Grant permissions
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);
        
        emit ValueSet(msg.sender);
    }
    
    /// @notice Get the encrypted value
    /// @return The encrypted value
    function getEncryptedValue() external view returns (euint32) {
        return _encryptedValue;
    }
    
    /// @notice Add to the encrypted value
    /// @param _encryptedInput The encrypted input to add
    /// @param _inputProof The proof for the encrypted input
    /// @dev This demonstrates that every encrypted input needs a proof
    function addToValue(externalEuint32 _encryptedInput, bytes calldata _inputProof) external {
        // Every encrypted input must have a proof
        euint32 encryptedInput = FHE.fromExternal(_encryptedInput, _inputProof);
        
        // Perform operation
        _encryptedValue = FHE.add(_encryptedValue, encryptedInput);
        
        // Grant permissions for result
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);
    }
    
    /// @notice Example with multiple encrypted inputs
    /// @param _input1 First encrypted input
    /// @param _proof1 Proof for first input
    /// @param _input2 Second encrypted input
    /// @param _proof2 Proof for second input
    /// @dev Each encrypted input needs its own proof
    function addTwoValues(
        externalEuint32 _input1,
        bytes calldata _proof1,
        externalEuint32 _input2,
        bytes calldata _proof2
    ) external {
        // Each input needs its own proof
        euint32 encrypted1 = FHE.fromExternal(_input1, _proof1);
        euint32 encrypted2 = FHE.fromExternal(_input2, _proof2);
        
        // Perform operation
        _encryptedValue = FHE.add(encrypted1, encrypted2);
        
        // Grant permissions
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);
    }
}


```

{% endtab %}

{% tab title="InputProofBasics.ts" %}

```typescript
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { ethers, fhevm } from "hardhat";
import { InputProofBasics, InputProofBasics__factory } from "../../types";
import { expect } from "chai";
import { FhevmType } from "@fhevm/hardhat-plugin";

/**
 * @chapter input-proofs
 * @title Input Proof Basics Test Suite
 * @notice Tests demonstrating what input proofs are and why they're needed
 */

type Signers = {
  deployer: HardhatEthersSigner;
  alice: HardhatEthersSigner;
};

async function deployFixture() {
  const factory = (await ethers.getContractFactory("InputProofBasics")) as InputProofBasics__factory;
  const contract = (await factory.deploy()) as InputProofBasics;
  const contractAddress = await contract.getAddress();
  return { contract, contractAddress };
}

describe("InputProofBasics", function () {
  let signers: Signers;
  let contract: InputProofBasics;
  let contractAddress: string;

  before(async function () {
    const ethSigners: HardhatEthersSigner[] = await ethers.getSigners();
    signers = { deployer: ethSigners[0], alice: ethSigners[1] };
  });

  beforeEach(async function () {
    if (!fhevm.isMock) {
      this.skip();
    }
    ({ contract, contractAddress } = await deployFixture());
  });

  it("should set value with encrypted input and proof", async function () {
    const clearValue = 42;
    const encrypted = await fhevm
      .createEncryptedInput(contractAddress, signers.alice.address)
      .add32(clearValue)
      .encrypt();

    await contract
      .connect(signers.alice)
      .setValue(encrypted.handles[0], encrypted.inputProof);

    const encryptedValue = await contract.connect(signers.alice).getEncryptedValue();
    const decrypted = await fhevm.userDecryptEuint(
      FhevmType.euint32,
      encryptedValue,
      contractAddress,
      signers.alice,
    );

    expect(decrypted).to.eq(clearValue);
  });

  it("should add to value with proof", async function () {
    // Set initial value
    const initialValue = 10;
    const encrypted1 = await fhevm
      .createEncryptedInput(contractAddress, signers.alice.address)
      .add32(initialValue)
      .encrypt();
    await contract.connect(signers.alice).setValue(encrypted1.handles[0], encrypted1.inputProof);

    // Add to value
    const addValue = 5;
    const encrypted2 = await fhevm
      .createEncryptedInput(contractAddress, signers.alice.address)
      .add32(addValue)
      .encrypt();
    await contract.connect(signers.alice).addToValue(encrypted2.handles[0], encrypted2.inputProof);

    const encryptedValue = await contract.connect(signers.alice).getEncryptedValue();
    const decrypted = await fhevm.userDecryptEuint(
      FhevmType.euint32,
      encryptedValue,
      contractAddress,
      signers.alice,
    );

    expect(decrypted).to.eq(15); // 10 + 5
  });

  it("should handle multiple inputs with separate proofs", async function () {
    const value1 = 10;
    const value2 = 20;
    
    const encrypted1 = await fhevm
      .createEncryptedInput(contractAddress, signers.alice.address)
      .add32(value1)
      .encrypt();
    
    const encrypted2 = await fhevm
      .createEncryptedInput(contractAddress, signers.alice.address)
      .add32(value2)
      .encrypt();

    await contract
      .connect(signers.alice)
      .addTwoValues(
        encrypted1.handles[0],
        encrypted1.inputProof,
        encrypted2.handles[0],
        encrypted2.inputProof
      );

    const encryptedValue = await contract.connect(signers.alice).getEncryptedValue();
    const decrypted = await fhevm.userDecryptEuint(
      FhevmType.euint32,
      encryptedValue,
      contractAddress,
      signers.alice,
    );

    expect(decrypted).to.eq(30); // 10 + 20
  });

  // ❌ Common Pitfalls
  describe("❌ Common Pitfalls", function () {
    it("should fail when using wrong signer for encrypted input", async function () {
      // Common pitfall: Using wrong signer address in createEncryptedInput
      const clearValue = 42;
      const encrypted = await fhevm
        .createEncryptedInput(contractAddress, signers.deployer.address) // Wrong signer!
        .add32(clearValue)
        .encrypt();

      // Should fail because signer doesn't match the transaction signer
      await expect(
        contract
          .connect(signers.alice)
          .setValue(encrypted.handles[0], encrypted.inputProof)
      ).to.be.reverted;
    });

    it("should fail when using invalid input proof", async function () {
      const clearValue = 42;
      const encrypted = await fhevm
        .createEncryptedInput(contractAddress, signers.alice.address)
        .add32(clearValue)
        .encrypt();

      // Use invalid proof (wrong format)
      const invalidProof = "0x" + "00".repeat(32);

      // Should fail with invalid proof
      await expect(
        contract
          .connect(signers.alice)
          .setValue(encrypted.handles[0], invalidProof)
      ).to.be.reverted;
    });

    it("should fail when using proof for different handle", async function () {
      const value1 = 10;
      const value2 = 20;
      
      const encrypted1 = await fhevm
        .createEncryptedInput(contractAddress, signers.alice.address)
        .add32(value1)
        .encrypt();
      
      const encrypted2 = await fhevm
        .createEncryptedInput(contractAddress, signers.alice.address)
        .add32(value2)
        .encrypt();

      // Use proof from encrypted1 with handle from encrypted2 (should fail)
      await expect(
        contract
          .connect(signers.alice)
          .setValue(encrypted2.handles[0], encrypted1.inputProof)
      ).to.be.reverted;
    });
  });
});


```

{% endtab %}

{% endtabs %}
